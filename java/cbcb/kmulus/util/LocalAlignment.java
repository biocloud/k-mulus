package cbcb.kmulus.util;

import org.apache.hadoop.io.Text;


/** 
 * Implementation of the Smith-Waterman algorithm. Represents the {@link Alignment} generated by
 * this algorithm.
 */
public class LocalAlignment implements Alignment {
	
	public final static int SCORE_FACTOR = 10000;
	
	private int score, len1, len2;

	public LocalAlignment(int score, int len1, int len2) {
		this.score = score;
		this.len1 = len1;
		this.len2 = len2;
	}
	
	/** 
	 * Aligns the given sequences with Smith-Waterman according to the given parameters.
	 * 
	 * @param s1 the first sequence, in FASTA format
	 * @param s2 the second sequence, in FASTA format
	 * @param m the score for matching two identical characters (should be positive)
	 * @param mm the score for mismatching two different characters (should be negative)
	 * @param g the score for opening a gap (should be negative)
	 * @param e the score for extending a gap (should be negative)
	 * 
	 * @return the {@link LocalAlignment} between {@code s1} and {@code s2}
	 */
	public static LocalAlignment getLocalAlignment(Text s1, Text s2, int m, int mm, int g, int e) {
		
		/* Skip past the sequence ID. */
		int start1 = s1.find(" ") + 1, start2 = s2.find(" ") + 1;
		int len1 = s1.getLength() - start1, len2 = s2.getLength() - start2;

		/* 
		 * Only two consecutive rows are needed at a time in memory for each of 4 tables:
		 * V is the best score thus far, G is the best score with a match at the end,
		 * E is the best score with a gap in s1, F is the best score with a gap in s2.
		 */
		int[] lastRowV = new int[len2 + 1], lastRowF = new int[len2 + 1];
		int[] rowV = new int[len2 + 1], rowG = new int[len2 + 1], 
			rowE = new int[len2 + 1], rowF = new int[len2 + 1];

		int max = 0;

		/* Main loop for determining the alignment. */
		for (int i = 1; i <= len1; i++) {

			/*Initialize first columns.*/
			rowV[0] = rowG[0] = rowE[0] = rowF[0] = 0;

			for(int j = 1; j <= len2; j++) {

				rowG[j] = lastRowV[j-1] + (s1.charAt(start1 + i-1) == s2.charAt(start2 + j-1) ? m : mm );
				rowE[j] = Math.max(rowE[j-1], rowV[j-1] + g) + e;
				rowF[j] = Math.max(lastRowF[j], lastRowV[j] + g) + e;

				if(rowG[j] >= rowE[j] && rowG[j] >= rowF[j]) {
					rowV[j] = rowG[j];

				} else if(rowE[j] >= rowG[j] && rowE[j] >= rowF[j]) {
					rowV[j] = rowE[j];

				} else {
					rowV[j] = rowF[j];
				}

				/* Track the maximum. */
				if(rowV[j] > max) {
					max = rowV[j];
				}

				/* If the score is below zero, terminate the sequence. */
				if(rowV[j] <= 0) {
					rowV[j] = 0;
				}
			}

			/* Adjust reading frame down a row. */
			for(int k = 0; k < rowV.length; k++) {
				lastRowV[k] = rowV[k];
				lastRowF[k] = rowF[k];
			}
		}

		return new LocalAlignment(max, len1, len2);
	}

	public int getScore() {
		return score;
	}
	
	@Override
	public long getDistance() {
		return SCORE_FACTOR / (score + 1);
	}

	public int getMaxPossibleAlignmentLen() {
		return Math.min(len1, len2);
	}
}
