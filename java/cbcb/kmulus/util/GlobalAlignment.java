package cbcb.kmulus.util;

import org.apache.hadoop.io.Text;


/** 
 * Implementation of the Needleman-Wunsch algorithm. Represents the {@link Alignment} generated by
 * this algorithm. 
 */
public class GlobalAlignment implements Alignment {

	final static int SCORE_FACTOR = 30;
	
	private int score;
	private int len1, len2;
	private int m;
	
	public GlobalAlignment(int score, int len1, int len2, int m) {
		this.score = score;
		this.len1 = len1;
		this.len2 = len2;
		this.m = m;
	}

	/**
	 * Aligns two sequences using the given values.
	 * 
	 * @param s1 First sequence.
	 * @param s2 Second sequence.
	 * @param a  Value awarded for aligning two equal characters.
	 * @param x  Value awarded for aligning two different characters.
	 * @param g  Value awarded for matching a character to a gap.
	 * @return   The alignment of the two sequences.
	 */
	public static GlobalAlignment getGlobalAlignment(Text s1, Text s2, int a, int x, int g) {
		/*Skip past the sequence ID*/
		int start1 = s1.find(" ")+1, start2 = s2.find(" ")+1;

		int len1 = s1.getLength() - start1, len2 = s2.getLength() - start2;

		/*Only two consecutive rows are needed at a time in memory.*/
		int[] lastRow = new int[len2 + 1];
		int[] row = new int[len2 + 1];

		/*Initialize the first row*/
		for(int i = 0; i < len2; i++) {
			lastRow[i + 1] = lastRow[i] + g;
		}

		/*Main loop for determining the alignment.*/
		for(int i = 1; i <= len1; i++) {

			row[0]= lastRow[0] + g; //initialize first column
			for(int j = 1; j <= len2; j++) {

				int leftScore = row[j-1] + g;
				int diagScore = lastRow[j-1] + (s1.charAt(i+start1-1) == s2.charAt(j+start2-1) ? a : x);
				int upScore = lastRow[j] + g;

				if(diagScore >= leftScore && diagScore >= upScore) {
					row[j] = diagScore;

				} else if(leftScore >= diagScore && leftScore >= upScore) {
					row[j] = leftScore;

				} else {
					row[j] = upScore;
				}
			}

			for(int k = 0; k < row.length; k++) {
				lastRow[k] = row[k];
			}
		}

		return new GlobalAlignment(row[len2], len1, len2, row[row.length-1]);
	}
	
	public int getScore() {
		return score;
	}

	@Override
	public long getDistance() {
		int maxScore = m * Math.min(len1, len2);
		return SCORE_FACTOR * (maxScore - score) / (len1 + len2);
	}

}
